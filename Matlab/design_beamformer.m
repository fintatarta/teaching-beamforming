function [h, A, theta]=design_beamformer (angles, N, step, freq, vel) 
% DESIGN_BEAMFORMER           Brief description
%
%      Synopsys:
%
%            [H, A, THETA]=DESIGN_BEAMFORMER (ANGLES, N, STEP, FREQ, VEL) 
%
%      Parameters:
%
%           ANGLES = [FROM TO]
%           N      = Number of microphone
%           STEP   = Distance between mics in meters
%           FREQ   = Frequency of the signal in Hz
%           VEL    = Speed of sound in m/s
%
%      Description:
%
%           NONE
%
%      Defaults:
%
%           FREQ = 3000 Hz
%           VEL  = 335 m/s
%
%      See also: 
%
%           NONE
%

%%
%% Default handling
%%

%
% Call parsing
%

%
% Default values
%

%%
%% True code
%%

if nargin < 5 
  freq = 3000;
end

if nargin < 6
  vel = 335; 
end

K = step*freq/vel;

%
% FROM and TO are given by the user as angles with respect
% to the  direction orthogonal to the axis where the microphones
% are placed, see the picture
%
%                 |      /
%                 |     /
%                 | U  /
%                 |   /
%                 |  /
%                 | / Theta
%                 |/
%  ----*--*--*----+--*--*--*--*-------
%
% The '*' are the microphones, U is the angle given by the 
% user (in degrees) and Theta is the angle we need.  It is clear that
% Theta = pi/2-U  (U in figure is positive)
%

angles = angles*pi/180;

from = pi/2 - angles(1);
to   = pi/2 - angles(2);

f_lo = K*cos(from)
f_hi = K*cos(to)
middle = K*cos((from+to)/2);

%
% Now, I want a filter whose frequency response
%
% (i)  the modulus has a maximum in MIDDLE
% (ii) said maximum is equal to 1
% (iii) it is as small as possible  outside
%   the frequency interval [f_lo, f_hi].
%
% The condition of being equal to 1 in middle can be expressed as
%
%     W' * h = 1
%
% where h is the vector of filter coefficients and W is the vector
%
%  W(k) = exp(j*2*pi*MIDDLE*k), k=0, 1, ...
%
%
% The condition of an extreme of the modulus can be expressed by
% observing that the square of the modulus in MIDDLE can be expressed
% as
%
%    h'*W*W'*h
%
% By differentiating with respect to MIDDLE we obtain that it must be
%
%    h'*U*h = 0
%
% where U = (W*W').*(n-n') (that is, every entry of row r and column c
% of W*W' must be multplied by r-c).  Matrix U is skew-hermitian, therefore
% it is unitary similar to a diagonal matrix
%
%    U = A*D*A'
%
% It follows that it must be
%
%    h'*A*D*A'*h = g'*D*g = 0
%
% with g=A'*h.
% 
% The eigenvalues of U are
%
% (i) immaginary and pair-opposite or
% (ii) zero
%      
% Note that
%
% g'*D*g = \sum_k |g_k|^2 \lambda_k
%
% Suppose wlg that the first 2K eigenvalues are not zero and that
% consecutive eigenvalues differ by sign. It follows that g_k 
% for k > K can be arbitrary while it must be
%
%    |g_{2n}| = |g_{2n-1}| n<= K
%
% A sufficient (but not necessary) condition for the equality above is
%
%  g_{2n} = g_{2n-1}
%
% Therefore, g must belong to the space generated by K vectors with two "1"
% and N-2K vectors from the identity matrix.  Call C this basis matrix.  It
% follows that it must be
%
%   h \in Im(A*C) = Im(B)
%
% Now, combine constraint above with that W'*h = 1 by setting h=B*u.
% It follows that it must be
%
%     W'*A*C*u = W'*B*u = 1
%
% This is true if u=u0+v, where W'*B*u0=1 and v \in null(W'*B).  A suitable
% choice for u0 can be B'*W suitably scaled.  In other words, I need
% to search over
%
%   h = B*(u0 + K*s)   where K=null(W'*B), s \in \complessi^L
%     = B*u0 + B*K*s   



n = (0:(N-1))';

W = exp(j*2*pi*middle*n);
U = (W*W').*(n-n'); % Differntiated wrt middle

[A, D]=eig(U);

[D, sorting_perm]=sort(abs(diag(D))); % Sort the eigenvalues in increasing
			     % order

A=A(:, sorting_perm);  % Adjust A 

last_zero_idx = max(find(D < 1e-6));  % Find the last zero eigenvalue

if mod(N-last_zero_idx, 2) == 1
  % sanity check, the condition above should follow from the
  % skew-hermitianity of U
  error('N-idx pari')
end

sampler = get_sampler(f_lo, f_hi, n);

best_val = 1000;
best_h = [];

for th=0:(2*pi*0.02):(2*pi)
  ph = exp(j*2*th);
  blk_zero = eye(last_zero_idx);                     % Free entries
  blk_pair = kron(eye((N-last_zero_idx)/2), [1;ph]);  % Pairwise equal
  C = blkdiag(blk_zero, blk_pair);         % Basis C
  B = A*C;


  u0 = B'*W;
  h0 = B*u0 / (W'*B*u0);
  H = B*null(W'*B);


				%
% Sanity check
%
  if norm(W'*H) > 1.0e-4 
    error('BUG: W*base_null too large');
  end



%
% Find the component with respect to base_null of the optimal
% vector orthogonal to W 
%
  [X, fval]=fminunc(@(x) objective(x, h0, H, sampler), rand(size(H,2), 2)-0.5);

  if fval < best_val
    best_val = fval;
    best_th = th;
    best_h = h0 + H*complessify(X);
    best_X = X;
    
    display([abs(W'*best_h), max(abs(sampler'*best_h)), th])
  end
%
% Apply the basis and add the bias to satisfy the constraint of 
% unitary response at MIDDLE
%
end

h=best_h;

%
% Compute the response
%
theta = -pi/2:0.001:pi/2;
f = K*cos(pi/2-theta);
A = exp(j*2*pi*n*f)'*h;

%
% Give to the user theta in degrees
%
theta = theta*180/pi;

function x=objective(u, u0, base, sampler)

h = u0 + base*complessify(u);

x=max(abs(sampler'*h));

function v=complessify(u)

v =  u * [1 ; j];

function sampler=get_sampler(f_lo, f_hi, n)
%
% We do a brutal optimization by sampling the response 
% over a number of frequencies outside the "passband" from .. to.
%
  f = -0.5:0.001:0.5;                    % Frequency set
  idx = find((f > f_lo) .* (f < f_hi));  % Remove the freq in the passband
  f(idx) = [];

%
% By multiplying sampler by the "impulse response" we get the 
% frequency response at the frequencies in f
%
sampler = exp(j*2*pi*n*f);
